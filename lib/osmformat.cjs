// This file is auto generated by the protocol-buffers compiler

/* eslint-disable quotes */
/* eslint-disable indent */
/* eslint-disable no-redeclare */
/* eslint-disable camelcase */

// Remember to `npm install --save protocol-buffers-encodings`
var encodings = require('protocol-buffers-encodings')
var varint = encodings.varint
var skip = encodings.skip

var HeaderBlock = exports.HeaderBlock = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var HeaderBBox = exports.HeaderBBox = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var PrimitiveBlock = exports.PrimitiveBlock = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var PrimitiveGroup = exports.PrimitiveGroup = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var StringTable = exports.StringTable = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var Info = exports.Info = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var DenseInfo = exports.DenseInfo = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var ChangeSet = exports.ChangeSet = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var Node = exports.Node = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var DenseNodes = exports.DenseNodes = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var Way = exports.Way = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var Relation = exports.Relation = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

defineHeaderBlock()
defineHeaderBBox()
definePrimitiveBlock()
definePrimitiveGroup()
defineStringTable()
defineInfo()
defineDenseInfo()
defineChangeSet()
defineNode()
defineDenseNodes()
defineWay()
defineRelation()

function defineHeaderBlock () {
  HeaderBlock.encodingLength = encodingLength
  HeaderBlock.encode = encode
  HeaderBlock.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.bbox)) {
      var len = HeaderBBox.encodingLength(obj.bbox)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    if (defined(obj.required_features)) {
      for (var i = 0; i < obj.required_features.length; i++) {
        if (!defined(obj.required_features[i])) continue
        var len = encodings.string.encodingLength(obj.required_features[i])
        length += 1 + len
      }
    }
    if (defined(obj.optional_features)) {
      for (var i = 0; i < obj.optional_features.length; i++) {
        if (!defined(obj.optional_features[i])) continue
        var len = encodings.string.encodingLength(obj.optional_features[i])
        length += 1 + len
      }
    }
    if (defined(obj.writingprogram)) {
      var len = encodings.string.encodingLength(obj.writingprogram)
      length += 2 + len
    }
    if (defined(obj.source)) {
      var len = encodings.string.encodingLength(obj.source)
      length += 2 + len
    }
    if (defined(obj.osmosis_replication_timestamp)) {
      var len = encodings.int64.encodingLength(obj.osmosis_replication_timestamp)
      length += 2 + len
    }
    if (defined(obj.osmosis_replication_sequence_number)) {
      var len = encodings.int64.encodingLength(obj.osmosis_replication_sequence_number)
      length += 2 + len
    }
    if (defined(obj.osmosis_replication_base_url)) {
      var len = encodings.string.encodingLength(obj.osmosis_replication_base_url)
      length += 2 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.bbox)) {
      buf[offset++] = 10
      varint.encode(HeaderBBox.encodingLength(obj.bbox), buf, offset)
      offset += varint.encode.bytes
      HeaderBBox.encode(obj.bbox, buf, offset)
      offset += HeaderBBox.encode.bytes
    }
    if (defined(obj.required_features)) {
      for (var i = 0; i < obj.required_features.length; i++) {
        if (!defined(obj.required_features[i])) continue
        buf[offset++] = 34
        encodings.string.encode(obj.required_features[i], buf, offset)
        offset += encodings.string.encode.bytes
      }
    }
    if (defined(obj.optional_features)) {
      for (var i = 0; i < obj.optional_features.length; i++) {
        if (!defined(obj.optional_features[i])) continue
        buf[offset++] = 42
        encodings.string.encode(obj.optional_features[i], buf, offset)
        offset += encodings.string.encode.bytes
      }
    }
    if (defined(obj.writingprogram)) {
      buf[offset++] = 130
      buf[offset++] = 1
      encodings.string.encode(obj.writingprogram, buf, offset)
      offset += encodings.string.encode.bytes
    }
    if (defined(obj.source)) {
      buf[offset++] = 138
      buf[offset++] = 1
      encodings.string.encode(obj.source, buf, offset)
      offset += encodings.string.encode.bytes
    }
    if (defined(obj.osmosis_replication_timestamp)) {
      buf[offset++] = 128
      buf[offset++] = 2
      encodings.int64.encode(obj.osmosis_replication_timestamp, buf, offset)
      offset += encodings.int64.encode.bytes
    }
    if (defined(obj.osmosis_replication_sequence_number)) {
      buf[offset++] = 136
      buf[offset++] = 2
      encodings.int64.encode(obj.osmosis_replication_sequence_number, buf, offset)
      offset += encodings.int64.encode.bytes
    }
    if (defined(obj.osmosis_replication_base_url)) {
      buf[offset++] = 146
      buf[offset++] = 2
      encodings.string.encode(obj.osmosis_replication_base_url, buf, offset)
      offset += encodings.string.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      bbox: null,
      required_features: [],
      optional_features: [],
      writingprogram: "",
      source: "",
      osmosis_replication_timestamp: 0,
      osmosis_replication_sequence_number: 0,
      osmosis_replication_base_url: ""
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.bbox = HeaderBBox.decode(buf, offset, offset + len)
        offset += HeaderBBox.decode.bytes
        break
        case 4:
        obj.required_features.push(encodings.string.decode(buf, offset))
        offset += encodings.string.decode.bytes
        break
        case 5:
        obj.optional_features.push(encodings.string.decode(buf, offset))
        offset += encodings.string.decode.bytes
        break
        case 16:
        obj.writingprogram = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        break
        case 17:
        obj.source = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        break
        case 32:
        obj.osmosis_replication_timestamp = encodings.int64.decode(buf, offset)
        offset += encodings.int64.decode.bytes
        break
        case 33:
        obj.osmosis_replication_sequence_number = encodings.int64.decode(buf, offset)
        offset += encodings.int64.decode.bytes
        break
        case 34:
        obj.osmosis_replication_base_url = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineHeaderBBox () {
  HeaderBBox.encodingLength = encodingLength
  HeaderBBox.encode = encode
  HeaderBBox.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (!defined(obj.left)) throw new Error("left is required")
    var len = encodings.sint64.encodingLength(obj.left)
    length += 1 + len
    if (!defined(obj.right)) throw new Error("right is required")
    var len = encodings.sint64.encodingLength(obj.right)
    length += 1 + len
    if (!defined(obj.top)) throw new Error("top is required")
    var len = encodings.sint64.encodingLength(obj.top)
    length += 1 + len
    if (!defined(obj.bottom)) throw new Error("bottom is required")
    var len = encodings.sint64.encodingLength(obj.bottom)
    length += 1 + len
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (!defined(obj.left)) throw new Error("left is required")
    buf[offset++] = 8
    encodings.sint64.encode(obj.left, buf, offset)
    offset += encodings.sint64.encode.bytes
    if (!defined(obj.right)) throw new Error("right is required")
    buf[offset++] = 16
    encodings.sint64.encode(obj.right, buf, offset)
    offset += encodings.sint64.encode.bytes
    if (!defined(obj.top)) throw new Error("top is required")
    buf[offset++] = 24
    encodings.sint64.encode(obj.top, buf, offset)
    offset += encodings.sint64.encode.bytes
    if (!defined(obj.bottom)) throw new Error("bottom is required")
    buf[offset++] = 32
    encodings.sint64.encode(obj.bottom, buf, offset)
    offset += encodings.sint64.encode.bytes
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }
    var found0 = false
    var found1 = false
    var found2 = false
    var found3 = false
    while (true) {
      if (end <= offset) {
        if (!found0 || !found1 || !found2 || !found3) throw new Error("Decoded message is not valid")
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.left = encodings.sint64.decode(buf, offset)
        offset += encodings.sint64.decode.bytes
        found0 = true
        break
        case 2:
        obj.right = encodings.sint64.decode(buf, offset)
        offset += encodings.sint64.decode.bytes
        found1 = true
        break
        case 3:
        obj.top = encodings.sint64.decode(buf, offset)
        offset += encodings.sint64.decode.bytes
        found2 = true
        break
        case 4:
        obj.bottom = encodings.sint64.decode(buf, offset)
        offset += encodings.sint64.decode.bytes
        found3 = true
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function definePrimitiveBlock () {
  PrimitiveBlock.encodingLength = encodingLength
  PrimitiveBlock.encode = encode
  PrimitiveBlock.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (!defined(obj.stringtable)) throw new Error("stringtable is required")
    var len = StringTable.encodingLength(obj.stringtable)
    length += varint.encodingLength(len)
    length += 1 + len
    if (defined(obj.primitivegroup)) {
      for (var i = 0; i < obj.primitivegroup.length; i++) {
        if (!defined(obj.primitivegroup[i])) continue
        var len = PrimitiveGroup.encodingLength(obj.primitivegroup[i])
        length += varint.encodingLength(len)
        length += 1 + len
      }
    }
    if (defined(obj.granularity)) {
      var len = encodings.int32.encodingLength(obj.granularity)
      length += 2 + len
    }
    if (defined(obj.lat_offset)) {
      var len = encodings.int64.encodingLength(obj.lat_offset)
      length += 2 + len
    }
    if (defined(obj.lon_offset)) {
      var len = encodings.int64.encodingLength(obj.lon_offset)
      length += 2 + len
    }
    if (defined(obj.date_granularity)) {
      var len = encodings.int32.encodingLength(obj.date_granularity)
      length += 2 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (!defined(obj.stringtable)) throw new Error("stringtable is required")
    buf[offset++] = 10
    varint.encode(StringTable.encodingLength(obj.stringtable), buf, offset)
    offset += varint.encode.bytes
    StringTable.encode(obj.stringtable, buf, offset)
    offset += StringTable.encode.bytes
    if (defined(obj.primitivegroup)) {
      for (var i = 0; i < obj.primitivegroup.length; i++) {
        if (!defined(obj.primitivegroup[i])) continue
        buf[offset++] = 18
        varint.encode(PrimitiveGroup.encodingLength(obj.primitivegroup[i]), buf, offset)
        offset += varint.encode.bytes
        PrimitiveGroup.encode(obj.primitivegroup[i], buf, offset)
        offset += PrimitiveGroup.encode.bytes
      }
    }
    if (defined(obj.granularity)) {
      buf[offset++] = 136
      buf[offset++] = 1
      encodings.int32.encode(obj.granularity, buf, offset)
      offset += encodings.int32.encode.bytes
    }
    if (defined(obj.lat_offset)) {
      buf[offset++] = 152
      buf[offset++] = 1
      encodings.int64.encode(obj.lat_offset, buf, offset)
      offset += encodings.int64.encode.bytes
    }
    if (defined(obj.lon_offset)) {
      buf[offset++] = 160
      buf[offset++] = 1
      encodings.int64.encode(obj.lon_offset, buf, offset)
      offset += encodings.int64.encode.bytes
    }
    if (defined(obj.date_granularity)) {
      buf[offset++] = 144
      buf[offset++] = 1
      encodings.int32.encode(obj.date_granularity, buf, offset)
      offset += encodings.int32.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      stringtable: null,
      primitivegroup: [],
      granularity: 100,
      lat_offset: 0,
      lon_offset: 0,
      date_granularity: 1000
    }
    var found0 = false
    while (true) {
      if (end <= offset) {
        if (!found0) throw new Error("Decoded message is not valid")
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.stringtable = StringTable.decode(buf, offset, offset + len)
        offset += StringTable.decode.bytes
        found0 = true
        break
        case 2:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.primitivegroup.push(PrimitiveGroup.decode(buf, offset, offset + len))
        offset += PrimitiveGroup.decode.bytes
        break
        case 17:
        obj.granularity = encodings.int32.decode(buf, offset)
        offset += encodings.int32.decode.bytes
        break
        case 19:
        obj.lat_offset = encodings.int64.decode(buf, offset)
        offset += encodings.int64.decode.bytes
        break
        case 20:
        obj.lon_offset = encodings.int64.decode(buf, offset)
        offset += encodings.int64.decode.bytes
        break
        case 18:
        obj.date_granularity = encodings.int32.decode(buf, offset)
        offset += encodings.int32.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function definePrimitiveGroup () {
  PrimitiveGroup.encodingLength = encodingLength
  PrimitiveGroup.encode = encode
  PrimitiveGroup.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.nodes)) {
      for (var i = 0; i < obj.nodes.length; i++) {
        if (!defined(obj.nodes[i])) continue
        var len = Node.encodingLength(obj.nodes[i])
        length += varint.encodingLength(len)
        length += 1 + len
      }
    }
    if (defined(obj.dense)) {
      var len = DenseNodes.encodingLength(obj.dense)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    if (defined(obj.ways)) {
      for (var i = 0; i < obj.ways.length; i++) {
        if (!defined(obj.ways[i])) continue
        var len = Way.encodingLength(obj.ways[i])
        length += varint.encodingLength(len)
        length += 1 + len
      }
    }
    if (defined(obj.relations)) {
      for (var i = 0; i < obj.relations.length; i++) {
        if (!defined(obj.relations[i])) continue
        var len = Relation.encodingLength(obj.relations[i])
        length += varint.encodingLength(len)
        length += 1 + len
      }
    }
    if (defined(obj.changesets)) {
      for (var i = 0; i < obj.changesets.length; i++) {
        if (!defined(obj.changesets[i])) continue
        var len = ChangeSet.encodingLength(obj.changesets[i])
        length += varint.encodingLength(len)
        length += 1 + len
      }
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.nodes)) {
      for (var i = 0; i < obj.nodes.length; i++) {
        if (!defined(obj.nodes[i])) continue
        buf[offset++] = 10
        varint.encode(Node.encodingLength(obj.nodes[i]), buf, offset)
        offset += varint.encode.bytes
        Node.encode(obj.nodes[i], buf, offset)
        offset += Node.encode.bytes
      }
    }
    if (defined(obj.dense)) {
      buf[offset++] = 18
      varint.encode(DenseNodes.encodingLength(obj.dense), buf, offset)
      offset += varint.encode.bytes
      DenseNodes.encode(obj.dense, buf, offset)
      offset += DenseNodes.encode.bytes
    }
    if (defined(obj.ways)) {
      for (var i = 0; i < obj.ways.length; i++) {
        if (!defined(obj.ways[i])) continue
        buf[offset++] = 26
        varint.encode(Way.encodingLength(obj.ways[i]), buf, offset)
        offset += varint.encode.bytes
        Way.encode(obj.ways[i], buf, offset)
        offset += Way.encode.bytes
      }
    }
    if (defined(obj.relations)) {
      for (var i = 0; i < obj.relations.length; i++) {
        if (!defined(obj.relations[i])) continue
        buf[offset++] = 34
        varint.encode(Relation.encodingLength(obj.relations[i]), buf, offset)
        offset += varint.encode.bytes
        Relation.encode(obj.relations[i], buf, offset)
        offset += Relation.encode.bytes
      }
    }
    if (defined(obj.changesets)) {
      for (var i = 0; i < obj.changesets.length; i++) {
        if (!defined(obj.changesets[i])) continue
        buf[offset++] = 42
        varint.encode(ChangeSet.encodingLength(obj.changesets[i]), buf, offset)
        offset += varint.encode.bytes
        ChangeSet.encode(obj.changesets[i], buf, offset)
        offset += ChangeSet.encode.bytes
      }
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      nodes: [],
      dense: null,
      ways: [],
      relations: [],
      changesets: []
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.nodes.push(Node.decode(buf, offset, offset + len))
        offset += Node.decode.bytes
        break
        case 2:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.dense = DenseNodes.decode(buf, offset, offset + len)
        offset += DenseNodes.decode.bytes
        break
        case 3:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.ways.push(Way.decode(buf, offset, offset + len))
        offset += Way.decode.bytes
        break
        case 4:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.relations.push(Relation.decode(buf, offset, offset + len))
        offset += Relation.decode.bytes
        break
        case 5:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.changesets.push(ChangeSet.decode(buf, offset, offset + len))
        offset += ChangeSet.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineStringTable () {
  StringTable.encodingLength = encodingLength
  StringTable.encode = encode
  StringTable.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.s)) {
      for (var i = 0; i < obj.s.length; i++) {
        if (!defined(obj.s[i])) continue
        var len = encodings.bytes.encodingLength(obj.s[i])
        length += 1 + len
      }
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.s)) {
      for (var i = 0; i < obj.s.length; i++) {
        if (!defined(obj.s[i])) continue
        buf[offset++] = 10
        encodings.bytes.encode(obj.s[i], buf, offset)
        offset += encodings.bytes.encode.bytes
      }
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      s: []
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.s.push(encodings.bytes.decode(buf, offset))
        offset += encodings.bytes.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineInfo () {
  Info.encodingLength = encodingLength
  Info.encode = encode
  Info.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.version)) {
      var len = encodings.int32.encodingLength(obj.version)
      length += 1 + len
    }
    if (defined(obj.timestamp)) {
      var len = encodings.int64.encodingLength(obj.timestamp)
      length += 1 + len
    }
    if (defined(obj.changeset)) {
      var len = encodings.int64.encodingLength(obj.changeset)
      length += 1 + len
    }
    if (defined(obj.uid)) {
      var len = encodings.int32.encodingLength(obj.uid)
      length += 1 + len
    }
    if (defined(obj.user_sid)) {
      var len = encodings.varint.encodingLength(obj.user_sid)
      length += 1 + len
    }
    if (defined(obj.visible)) {
      var len = encodings.bool.encodingLength(obj.visible)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.version)) {
      buf[offset++] = 8
      encodings.int32.encode(obj.version, buf, offset)
      offset += encodings.int32.encode.bytes
    }
    if (defined(obj.timestamp)) {
      buf[offset++] = 16
      encodings.int64.encode(obj.timestamp, buf, offset)
      offset += encodings.int64.encode.bytes
    }
    if (defined(obj.changeset)) {
      buf[offset++] = 24
      encodings.int64.encode(obj.changeset, buf, offset)
      offset += encodings.int64.encode.bytes
    }
    if (defined(obj.uid)) {
      buf[offset++] = 32
      encodings.int32.encode(obj.uid, buf, offset)
      offset += encodings.int32.encode.bytes
    }
    if (defined(obj.user_sid)) {
      buf[offset++] = 40
      encodings.varint.encode(obj.user_sid, buf, offset)
      offset += encodings.varint.encode.bytes
    }
    if (defined(obj.visible)) {
      buf[offset++] = 48
      encodings.bool.encode(obj.visible, buf, offset)
      offset += encodings.bool.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      version: -1,
      timestamp: 0,
      changeset: 0,
      uid: 0,
      user_sid: 0,
      visible: false
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.version = encodings.int32.decode(buf, offset)
        offset += encodings.int32.decode.bytes
        break
        case 2:
        obj.timestamp = encodings.int64.decode(buf, offset)
        offset += encodings.int64.decode.bytes
        break
        case 3:
        obj.changeset = encodings.int64.decode(buf, offset)
        offset += encodings.int64.decode.bytes
        break
        case 4:
        obj.uid = encodings.int32.decode(buf, offset)
        offset += encodings.int32.decode.bytes
        break
        case 5:
        obj.user_sid = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        break
        case 6:
        obj.visible = encodings.bool.decode(buf, offset)
        offset += encodings.bool.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineDenseInfo () {
  DenseInfo.encodingLength = encodingLength
  DenseInfo.encode = encode
  DenseInfo.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.version)) {
      var packedLen = 0
      for (var i = 0; i < obj.version.length; i++) {
        if (!defined(obj.version[i])) continue
        var len = encodings.int32.encodingLength(obj.version[i])
        packedLen += len
      }
      if (packedLen) {
        length += 1 + packedLen + varint.encodingLength(packedLen)
      }
    }
    if (defined(obj.timestamp)) {
      var packedLen = 0
      for (var i = 0; i < obj.timestamp.length; i++) {
        if (!defined(obj.timestamp[i])) continue
        var len = encodings.sint64.encodingLength(obj.timestamp[i])
        packedLen += len
      }
      if (packedLen) {
        length += 1 + packedLen + varint.encodingLength(packedLen)
      }
    }
    if (defined(obj.changeset)) {
      var packedLen = 0
      for (var i = 0; i < obj.changeset.length; i++) {
        if (!defined(obj.changeset[i])) continue
        var len = encodings.sint64.encodingLength(obj.changeset[i])
        packedLen += len
      }
      if (packedLen) {
        length += 1 + packedLen + varint.encodingLength(packedLen)
      }
    }
    if (defined(obj.uid)) {
      var packedLen = 0
      for (var i = 0; i < obj.uid.length; i++) {
        if (!defined(obj.uid[i])) continue
        var len = encodings.sint64.encodingLength(obj.uid[i])
        packedLen += len
      }
      if (packedLen) {
        length += 1 + packedLen + varint.encodingLength(packedLen)
      }
    }
    if (defined(obj.user_sid)) {
      var packedLen = 0
      for (var i = 0; i < obj.user_sid.length; i++) {
        if (!defined(obj.user_sid[i])) continue
        var len = encodings.sint64.encodingLength(obj.user_sid[i])
        packedLen += len
      }
      if (packedLen) {
        length += 1 + packedLen + varint.encodingLength(packedLen)
      }
    }
    if (defined(obj.visible)) {
      var packedLen = 0
      for (var i = 0; i < obj.visible.length; i++) {
        if (!defined(obj.visible[i])) continue
        var len = encodings.bool.encodingLength(obj.visible[i])
        packedLen += len
      }
      if (packedLen) {
        length += 1 + packedLen + varint.encodingLength(packedLen)
      }
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.version)) {
      var packedLen = 0
      for (var i = 0; i < obj.version.length; i++) {
        if (!defined(obj.version[i])) continue
        packedLen += encodings.int32.encodingLength(obj.version[i])
      }
      if (packedLen) {
        buf[offset++] = 10
        varint.encode(packedLen, buf, offset)
        offset += varint.encode.bytes
      }
      for (var i = 0; i < obj.version.length; i++) {
        if (!defined(obj.version[i])) continue
        encodings.int32.encode(obj.version[i], buf, offset)
        offset += encodings.int32.encode.bytes
      }
    }
    if (defined(obj.timestamp)) {
      var packedLen = 0
      for (var i = 0; i < obj.timestamp.length; i++) {
        if (!defined(obj.timestamp[i])) continue
        packedLen += encodings.sint64.encodingLength(obj.timestamp[i])
      }
      if (packedLen) {
        buf[offset++] = 18
        varint.encode(packedLen, buf, offset)
        offset += varint.encode.bytes
      }
      for (var i = 0; i < obj.timestamp.length; i++) {
        if (!defined(obj.timestamp[i])) continue
        encodings.sint64.encode(obj.timestamp[i], buf, offset)
        offset += encodings.sint64.encode.bytes
      }
    }
    if (defined(obj.changeset)) {
      var packedLen = 0
      for (var i = 0; i < obj.changeset.length; i++) {
        if (!defined(obj.changeset[i])) continue
        packedLen += encodings.sint64.encodingLength(obj.changeset[i])
      }
      if (packedLen) {
        buf[offset++] = 26
        varint.encode(packedLen, buf, offset)
        offset += varint.encode.bytes
      }
      for (var i = 0; i < obj.changeset.length; i++) {
        if (!defined(obj.changeset[i])) continue
        encodings.sint64.encode(obj.changeset[i], buf, offset)
        offset += encodings.sint64.encode.bytes
      }
    }
    if (defined(obj.uid)) {
      var packedLen = 0
      for (var i = 0; i < obj.uid.length; i++) {
        if (!defined(obj.uid[i])) continue
        packedLen += encodings.sint64.encodingLength(obj.uid[i])
      }
      if (packedLen) {
        buf[offset++] = 34
        varint.encode(packedLen, buf, offset)
        offset += varint.encode.bytes
      }
      for (var i = 0; i < obj.uid.length; i++) {
        if (!defined(obj.uid[i])) continue
        encodings.sint64.encode(obj.uid[i], buf, offset)
        offset += encodings.sint64.encode.bytes
      }
    }
    if (defined(obj.user_sid)) {
      var packedLen = 0
      for (var i = 0; i < obj.user_sid.length; i++) {
        if (!defined(obj.user_sid[i])) continue
        packedLen += encodings.sint64.encodingLength(obj.user_sid[i])
      }
      if (packedLen) {
        buf[offset++] = 42
        varint.encode(packedLen, buf, offset)
        offset += varint.encode.bytes
      }
      for (var i = 0; i < obj.user_sid.length; i++) {
        if (!defined(obj.user_sid[i])) continue
        encodings.sint64.encode(obj.user_sid[i], buf, offset)
        offset += encodings.sint64.encode.bytes
      }
    }
    if (defined(obj.visible)) {
      var packedLen = 0
      for (var i = 0; i < obj.visible.length; i++) {
        if (!defined(obj.visible[i])) continue
        packedLen += encodings.bool.encodingLength(obj.visible[i])
      }
      if (packedLen) {
        buf[offset++] = 50
        varint.encode(packedLen, buf, offset)
        offset += varint.encode.bytes
      }
      for (var i = 0; i < obj.visible.length; i++) {
        if (!defined(obj.visible[i])) continue
        encodings.bool.encode(obj.visible[i], buf, offset)
        offset += encodings.bool.encode.bytes
      }
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      version: [],
      timestamp: [],
      changeset: [],
      uid: [],
      user_sid: [],
      visible: []
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        var packedEnd = varint.decode(buf, offset)
        offset += varint.decode.bytes
        packedEnd += offset
        while (offset < packedEnd) {
          obj.version.push(encodings.int32.decode(buf, offset))
          offset += encodings.int32.decode.bytes
        }
        break
        case 2:
        var packedEnd = varint.decode(buf, offset)
        offset += varint.decode.bytes
        packedEnd += offset
        while (offset < packedEnd) {
          obj.timestamp.push(encodings.sint64.decode(buf, offset))
          offset += encodings.sint64.decode.bytes
        }
        break
        case 3:
        var packedEnd = varint.decode(buf, offset)
        offset += varint.decode.bytes
        packedEnd += offset
        while (offset < packedEnd) {
          obj.changeset.push(encodings.sint64.decode(buf, offset))
          offset += encodings.sint64.decode.bytes
        }
        break
        case 4:
        var packedEnd = varint.decode(buf, offset)
        offset += varint.decode.bytes
        packedEnd += offset
        while (offset < packedEnd) {
          obj.uid.push(encodings.sint64.decode(buf, offset))
          offset += encodings.sint64.decode.bytes
        }
        break
        case 5:
        var packedEnd = varint.decode(buf, offset)
        offset += varint.decode.bytes
        packedEnd += offset
        while (offset < packedEnd) {
          obj.user_sid.push(encodings.sint64.decode(buf, offset))
          offset += encodings.sint64.decode.bytes
        }
        break
        case 6:
        var packedEnd = varint.decode(buf, offset)
        offset += varint.decode.bytes
        packedEnd += offset
        while (offset < packedEnd) {
          obj.visible.push(encodings.bool.decode(buf, offset))
          offset += encodings.bool.decode.bytes
        }
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineChangeSet () {
  ChangeSet.encodingLength = encodingLength
  ChangeSet.encode = encode
  ChangeSet.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (!defined(obj.id)) throw new Error("id is required")
    var len = encodings.int64.encodingLength(obj.id)
    length += 1 + len
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (!defined(obj.id)) throw new Error("id is required")
    buf[offset++] = 8
    encodings.int64.encode(obj.id, buf, offset)
    offset += encodings.int64.encode.bytes
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      id: 0
    }
    var found0 = false
    while (true) {
      if (end <= offset) {
        if (!found0) throw new Error("Decoded message is not valid")
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.id = encodings.int64.decode(buf, offset)
        offset += encodings.int64.decode.bytes
        found0 = true
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineNode () {
  Node.encodingLength = encodingLength
  Node.encode = encode
  Node.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (!defined(obj.id)) throw new Error("id is required")
    var len = encodings.sint64.encodingLength(obj.id)
    length += 1 + len
    if (defined(obj.keys)) {
      var packedLen = 0
      for (var i = 0; i < obj.keys.length; i++) {
        if (!defined(obj.keys[i])) continue
        var len = encodings.varint.encodingLength(obj.keys[i])
        packedLen += len
      }
      if (packedLen) {
        length += 1 + packedLen + varint.encodingLength(packedLen)
      }
    }
    if (defined(obj.vals)) {
      var packedLen = 0
      for (var i = 0; i < obj.vals.length; i++) {
        if (!defined(obj.vals[i])) continue
        var len = encodings.varint.encodingLength(obj.vals[i])
        packedLen += len
      }
      if (packedLen) {
        length += 1 + packedLen + varint.encodingLength(packedLen)
      }
    }
    if (defined(obj.info)) {
      var len = Info.encodingLength(obj.info)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    if (!defined(obj.lat)) throw new Error("lat is required")
    var len = encodings.sint64.encodingLength(obj.lat)
    length += 1 + len
    if (!defined(obj.lon)) throw new Error("lon is required")
    var len = encodings.sint64.encodingLength(obj.lon)
    length += 1 + len
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (!defined(obj.id)) throw new Error("id is required")
    buf[offset++] = 8
    encodings.sint64.encode(obj.id, buf, offset)
    offset += encodings.sint64.encode.bytes
    if (defined(obj.keys)) {
      var packedLen = 0
      for (var i = 0; i < obj.keys.length; i++) {
        if (!defined(obj.keys[i])) continue
        packedLen += encodings.varint.encodingLength(obj.keys[i])
      }
      if (packedLen) {
        buf[offset++] = 18
        varint.encode(packedLen, buf, offset)
        offset += varint.encode.bytes
      }
      for (var i = 0; i < obj.keys.length; i++) {
        if (!defined(obj.keys[i])) continue
        encodings.varint.encode(obj.keys[i], buf, offset)
        offset += encodings.varint.encode.bytes
      }
    }
    if (defined(obj.vals)) {
      var packedLen = 0
      for (var i = 0; i < obj.vals.length; i++) {
        if (!defined(obj.vals[i])) continue
        packedLen += encodings.varint.encodingLength(obj.vals[i])
      }
      if (packedLen) {
        buf[offset++] = 26
        varint.encode(packedLen, buf, offset)
        offset += varint.encode.bytes
      }
      for (var i = 0; i < obj.vals.length; i++) {
        if (!defined(obj.vals[i])) continue
        encodings.varint.encode(obj.vals[i], buf, offset)
        offset += encodings.varint.encode.bytes
      }
    }
    if (defined(obj.info)) {
      buf[offset++] = 34
      varint.encode(Info.encodingLength(obj.info), buf, offset)
      offset += varint.encode.bytes
      Info.encode(obj.info, buf, offset)
      offset += Info.encode.bytes
    }
    if (!defined(obj.lat)) throw new Error("lat is required")
    buf[offset++] = 64
    encodings.sint64.encode(obj.lat, buf, offset)
    offset += encodings.sint64.encode.bytes
    if (!defined(obj.lon)) throw new Error("lon is required")
    buf[offset++] = 72
    encodings.sint64.encode(obj.lon, buf, offset)
    offset += encodings.sint64.encode.bytes
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      id: 0,
      keys: [],
      vals: [],
      info: null,
      lat: 0,
      lon: 0
    }
    var found0 = false
    var found4 = false
    var found5 = false
    while (true) {
      if (end <= offset) {
        if (!found0 || !found4 || !found5) throw new Error("Decoded message is not valid")
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.id = encodings.sint64.decode(buf, offset)
        offset += encodings.sint64.decode.bytes
        found0 = true
        break
        case 2:
        var packedEnd = varint.decode(buf, offset)
        offset += varint.decode.bytes
        packedEnd += offset
        while (offset < packedEnd) {
          obj.keys.push(encodings.varint.decode(buf, offset))
          offset += encodings.varint.decode.bytes
        }
        break
        case 3:
        var packedEnd = varint.decode(buf, offset)
        offset += varint.decode.bytes
        packedEnd += offset
        while (offset < packedEnd) {
          obj.vals.push(encodings.varint.decode(buf, offset))
          offset += encodings.varint.decode.bytes
        }
        break
        case 4:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.info = Info.decode(buf, offset, offset + len)
        offset += Info.decode.bytes
        break
        case 8:
        obj.lat = encodings.sint64.decode(buf, offset)
        offset += encodings.sint64.decode.bytes
        found4 = true
        break
        case 9:
        obj.lon = encodings.sint64.decode(buf, offset)
        offset += encodings.sint64.decode.bytes
        found5 = true
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineDenseNodes () {
  DenseNodes.encodingLength = encodingLength
  DenseNodes.encode = encode
  DenseNodes.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.id)) {
      var packedLen = 0
      for (var i = 0; i < obj.id.length; i++) {
        if (!defined(obj.id[i])) continue
        var len = encodings.sint64.encodingLength(obj.id[i])
        packedLen += len
      }
      if (packedLen) {
        length += 1 + packedLen + varint.encodingLength(packedLen)
      }
    }
    if (defined(obj.denseinfo)) {
      var len = DenseInfo.encodingLength(obj.denseinfo)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    if (defined(obj.lat)) {
      var packedLen = 0
      for (var i = 0; i < obj.lat.length; i++) {
        if (!defined(obj.lat[i])) continue
        var len = encodings.sint64.encodingLength(obj.lat[i])
        packedLen += len
      }
      if (packedLen) {
        length += 1 + packedLen + varint.encodingLength(packedLen)
      }
    }
    if (defined(obj.lon)) {
      var packedLen = 0
      for (var i = 0; i < obj.lon.length; i++) {
        if (!defined(obj.lon[i])) continue
        var len = encodings.sint64.encodingLength(obj.lon[i])
        packedLen += len
      }
      if (packedLen) {
        length += 1 + packedLen + varint.encodingLength(packedLen)
      }
    }
    if (defined(obj.keys_vals)) {
      var packedLen = 0
      for (var i = 0; i < obj.keys_vals.length; i++) {
        if (!defined(obj.keys_vals[i])) continue
        var len = encodings.int32.encodingLength(obj.keys_vals[i])
        packedLen += len
      }
      if (packedLen) {
        length += 1 + packedLen + varint.encodingLength(packedLen)
      }
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.id)) {
      var packedLen = 0
      for (var i = 0; i < obj.id.length; i++) {
        if (!defined(obj.id[i])) continue
        packedLen += encodings.sint64.encodingLength(obj.id[i])
      }
      if (packedLen) {
        buf[offset++] = 10
        varint.encode(packedLen, buf, offset)
        offset += varint.encode.bytes
      }
      for (var i = 0; i < obj.id.length; i++) {
        if (!defined(obj.id[i])) continue
        encodings.sint64.encode(obj.id[i], buf, offset)
        offset += encodings.sint64.encode.bytes
      }
    }
    if (defined(obj.denseinfo)) {
      buf[offset++] = 42
      varint.encode(DenseInfo.encodingLength(obj.denseinfo), buf, offset)
      offset += varint.encode.bytes
      DenseInfo.encode(obj.denseinfo, buf, offset)
      offset += DenseInfo.encode.bytes
    }
    if (defined(obj.lat)) {
      var packedLen = 0
      for (var i = 0; i < obj.lat.length; i++) {
        if (!defined(obj.lat[i])) continue
        packedLen += encodings.sint64.encodingLength(obj.lat[i])
      }
      if (packedLen) {
        buf[offset++] = 66
        varint.encode(packedLen, buf, offset)
        offset += varint.encode.bytes
      }
      for (var i = 0; i < obj.lat.length; i++) {
        if (!defined(obj.lat[i])) continue
        encodings.sint64.encode(obj.lat[i], buf, offset)
        offset += encodings.sint64.encode.bytes
      }
    }
    if (defined(obj.lon)) {
      var packedLen = 0
      for (var i = 0; i < obj.lon.length; i++) {
        if (!defined(obj.lon[i])) continue
        packedLen += encodings.sint64.encodingLength(obj.lon[i])
      }
      if (packedLen) {
        buf[offset++] = 74
        varint.encode(packedLen, buf, offset)
        offset += varint.encode.bytes
      }
      for (var i = 0; i < obj.lon.length; i++) {
        if (!defined(obj.lon[i])) continue
        encodings.sint64.encode(obj.lon[i], buf, offset)
        offset += encodings.sint64.encode.bytes
      }
    }
    if (defined(obj.keys_vals)) {
      var packedLen = 0
      for (var i = 0; i < obj.keys_vals.length; i++) {
        if (!defined(obj.keys_vals[i])) continue
        packedLen += encodings.int32.encodingLength(obj.keys_vals[i])
      }
      if (packedLen) {
        buf[offset++] = 82
        varint.encode(packedLen, buf, offset)
        offset += varint.encode.bytes
      }
      for (var i = 0; i < obj.keys_vals.length; i++) {
        if (!defined(obj.keys_vals[i])) continue
        encodings.int32.encode(obj.keys_vals[i], buf, offset)
        offset += encodings.int32.encode.bytes
      }
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      id: [],
      denseinfo: null,
      lat: [],
      lon: [],
      keys_vals: []
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        var packedEnd = varint.decode(buf, offset)
        offset += varint.decode.bytes
        packedEnd += offset
        while (offset < packedEnd) {
          obj.id.push(encodings.sint64.decode(buf, offset))
          offset += encodings.sint64.decode.bytes
        }
        break
        case 5:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.denseinfo = DenseInfo.decode(buf, offset, offset + len)
        offset += DenseInfo.decode.bytes
        break
        case 8:
        var packedEnd = varint.decode(buf, offset)
        offset += varint.decode.bytes
        packedEnd += offset
        while (offset < packedEnd) {
          obj.lat.push(encodings.sint64.decode(buf, offset))
          offset += encodings.sint64.decode.bytes
        }
        break
        case 9:
        var packedEnd = varint.decode(buf, offset)
        offset += varint.decode.bytes
        packedEnd += offset
        while (offset < packedEnd) {
          obj.lon.push(encodings.sint64.decode(buf, offset))
          offset += encodings.sint64.decode.bytes
        }
        break
        case 10:
        var packedEnd = varint.decode(buf, offset)
        offset += varint.decode.bytes
        packedEnd += offset
        while (offset < packedEnd) {
          obj.keys_vals.push(encodings.int32.decode(buf, offset))
          offset += encodings.int32.decode.bytes
        }
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineWay () {
  Way.encodingLength = encodingLength
  Way.encode = encode
  Way.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (!defined(obj.id)) throw new Error("id is required")
    var len = encodings.int64.encodingLength(obj.id)
    length += 1 + len
    if (defined(obj.keys)) {
      var packedLen = 0
      for (var i = 0; i < obj.keys.length; i++) {
        if (!defined(obj.keys[i])) continue
        var len = encodings.varint.encodingLength(obj.keys[i])
        packedLen += len
      }
      if (packedLen) {
        length += 1 + packedLen + varint.encodingLength(packedLen)
      }
    }
    if (defined(obj.vals)) {
      var packedLen = 0
      for (var i = 0; i < obj.vals.length; i++) {
        if (!defined(obj.vals[i])) continue
        var len = encodings.varint.encodingLength(obj.vals[i])
        packedLen += len
      }
      if (packedLen) {
        length += 1 + packedLen + varint.encodingLength(packedLen)
      }
    }
    if (defined(obj.info)) {
      var len = Info.encodingLength(obj.info)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    if (defined(obj.refs)) {
      var packedLen = 0
      for (var i = 0; i < obj.refs.length; i++) {
        if (!defined(obj.refs[i])) continue
        var len = encodings.sint64.encodingLength(obj.refs[i])
        packedLen += len
      }
      if (packedLen) {
        length += 1 + packedLen + varint.encodingLength(packedLen)
      }
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (!defined(obj.id)) throw new Error("id is required")
    buf[offset++] = 8
    encodings.int64.encode(obj.id, buf, offset)
    offset += encodings.int64.encode.bytes
    if (defined(obj.keys)) {
      var packedLen = 0
      for (var i = 0; i < obj.keys.length; i++) {
        if (!defined(obj.keys[i])) continue
        packedLen += encodings.varint.encodingLength(obj.keys[i])
      }
      if (packedLen) {
        buf[offset++] = 18
        varint.encode(packedLen, buf, offset)
        offset += varint.encode.bytes
      }
      for (var i = 0; i < obj.keys.length; i++) {
        if (!defined(obj.keys[i])) continue
        encodings.varint.encode(obj.keys[i], buf, offset)
        offset += encodings.varint.encode.bytes
      }
    }
    if (defined(obj.vals)) {
      var packedLen = 0
      for (var i = 0; i < obj.vals.length; i++) {
        if (!defined(obj.vals[i])) continue
        packedLen += encodings.varint.encodingLength(obj.vals[i])
      }
      if (packedLen) {
        buf[offset++] = 26
        varint.encode(packedLen, buf, offset)
        offset += varint.encode.bytes
      }
      for (var i = 0; i < obj.vals.length; i++) {
        if (!defined(obj.vals[i])) continue
        encodings.varint.encode(obj.vals[i], buf, offset)
        offset += encodings.varint.encode.bytes
      }
    }
    if (defined(obj.info)) {
      buf[offset++] = 34
      varint.encode(Info.encodingLength(obj.info), buf, offset)
      offset += varint.encode.bytes
      Info.encode(obj.info, buf, offset)
      offset += Info.encode.bytes
    }
    if (defined(obj.refs)) {
      var packedLen = 0
      for (var i = 0; i < obj.refs.length; i++) {
        if (!defined(obj.refs[i])) continue
        packedLen += encodings.sint64.encodingLength(obj.refs[i])
      }
      if (packedLen) {
        buf[offset++] = 66
        varint.encode(packedLen, buf, offset)
        offset += varint.encode.bytes
      }
      for (var i = 0; i < obj.refs.length; i++) {
        if (!defined(obj.refs[i])) continue
        encodings.sint64.encode(obj.refs[i], buf, offset)
        offset += encodings.sint64.encode.bytes
      }
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      id: 0,
      keys: [],
      vals: [],
      info: null,
      refs: []
    }
    var found0 = false
    while (true) {
      if (end <= offset) {
        if (!found0) throw new Error("Decoded message is not valid")
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.id = encodings.int64.decode(buf, offset)
        offset += encodings.int64.decode.bytes
        found0 = true
        break
        case 2:
        var packedEnd = varint.decode(buf, offset)
        offset += varint.decode.bytes
        packedEnd += offset
        while (offset < packedEnd) {
          obj.keys.push(encodings.varint.decode(buf, offset))
          offset += encodings.varint.decode.bytes
        }
        break
        case 3:
        var packedEnd = varint.decode(buf, offset)
        offset += varint.decode.bytes
        packedEnd += offset
        while (offset < packedEnd) {
          obj.vals.push(encodings.varint.decode(buf, offset))
          offset += encodings.varint.decode.bytes
        }
        break
        case 4:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.info = Info.decode(buf, offset, offset + len)
        offset += Info.decode.bytes
        break
        case 8:
        var packedEnd = varint.decode(buf, offset)
        offset += varint.decode.bytes
        packedEnd += offset
        while (offset < packedEnd) {
          obj.refs.push(encodings.sint64.decode(buf, offset))
          offset += encodings.sint64.decode.bytes
        }
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineRelation () {
  Relation.MemberType = {
    NODE: 0,
    WAY: 1,
    RELATION: 2
  }

  Relation.encodingLength = encodingLength
  Relation.encode = encode
  Relation.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (!defined(obj.id)) throw new Error("id is required")
    var len = encodings.int64.encodingLength(obj.id)
    length += 1 + len
    if (defined(obj.keys)) {
      var packedLen = 0
      for (var i = 0; i < obj.keys.length; i++) {
        if (!defined(obj.keys[i])) continue
        var len = encodings.varint.encodingLength(obj.keys[i])
        packedLen += len
      }
      if (packedLen) {
        length += 1 + packedLen + varint.encodingLength(packedLen)
      }
    }
    if (defined(obj.vals)) {
      var packedLen = 0
      for (var i = 0; i < obj.vals.length; i++) {
        if (!defined(obj.vals[i])) continue
        var len = encodings.varint.encodingLength(obj.vals[i])
        packedLen += len
      }
      if (packedLen) {
        length += 1 + packedLen + varint.encodingLength(packedLen)
      }
    }
    if (defined(obj.info)) {
      var len = Info.encodingLength(obj.info)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    if (defined(obj.roles_sid)) {
      var packedLen = 0
      for (var i = 0; i < obj.roles_sid.length; i++) {
        if (!defined(obj.roles_sid[i])) continue
        var len = encodings.int32.encodingLength(obj.roles_sid[i])
        packedLen += len
      }
      if (packedLen) {
        length += 1 + packedLen + varint.encodingLength(packedLen)
      }
    }
    if (defined(obj.memids)) {
      var packedLen = 0
      for (var i = 0; i < obj.memids.length; i++) {
        if (!defined(obj.memids[i])) continue
        var len = encodings.sint64.encodingLength(obj.memids[i])
        packedLen += len
      }
      if (packedLen) {
        length += 1 + packedLen + varint.encodingLength(packedLen)
      }
    }
    if (defined(obj.types)) {
      var packedLen = 0
      for (var i = 0; i < obj.types.length; i++) {
        if (!defined(obj.types[i])) continue
        var len = encodings.enum.encodingLength(obj.types[i])
        packedLen += len
      }
      if (packedLen) {
        length += 1 + packedLen + varint.encodingLength(packedLen)
      }
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (!defined(obj.id)) throw new Error("id is required")
    buf[offset++] = 8
    encodings.int64.encode(obj.id, buf, offset)
    offset += encodings.int64.encode.bytes
    if (defined(obj.keys)) {
      var packedLen = 0
      for (var i = 0; i < obj.keys.length; i++) {
        if (!defined(obj.keys[i])) continue
        packedLen += encodings.varint.encodingLength(obj.keys[i])
      }
      if (packedLen) {
        buf[offset++] = 18
        varint.encode(packedLen, buf, offset)
        offset += varint.encode.bytes
      }
      for (var i = 0; i < obj.keys.length; i++) {
        if (!defined(obj.keys[i])) continue
        encodings.varint.encode(obj.keys[i], buf, offset)
        offset += encodings.varint.encode.bytes
      }
    }
    if (defined(obj.vals)) {
      var packedLen = 0
      for (var i = 0; i < obj.vals.length; i++) {
        if (!defined(obj.vals[i])) continue
        packedLen += encodings.varint.encodingLength(obj.vals[i])
      }
      if (packedLen) {
        buf[offset++] = 26
        varint.encode(packedLen, buf, offset)
        offset += varint.encode.bytes
      }
      for (var i = 0; i < obj.vals.length; i++) {
        if (!defined(obj.vals[i])) continue
        encodings.varint.encode(obj.vals[i], buf, offset)
        offset += encodings.varint.encode.bytes
      }
    }
    if (defined(obj.info)) {
      buf[offset++] = 34
      varint.encode(Info.encodingLength(obj.info), buf, offset)
      offset += varint.encode.bytes
      Info.encode(obj.info, buf, offset)
      offset += Info.encode.bytes
    }
    if (defined(obj.roles_sid)) {
      var packedLen = 0
      for (var i = 0; i < obj.roles_sid.length; i++) {
        if (!defined(obj.roles_sid[i])) continue
        packedLen += encodings.int32.encodingLength(obj.roles_sid[i])
      }
      if (packedLen) {
        buf[offset++] = 66
        varint.encode(packedLen, buf, offset)
        offset += varint.encode.bytes
      }
      for (var i = 0; i < obj.roles_sid.length; i++) {
        if (!defined(obj.roles_sid[i])) continue
        encodings.int32.encode(obj.roles_sid[i], buf, offset)
        offset += encodings.int32.encode.bytes
      }
    }
    if (defined(obj.memids)) {
      var packedLen = 0
      for (var i = 0; i < obj.memids.length; i++) {
        if (!defined(obj.memids[i])) continue
        packedLen += encodings.sint64.encodingLength(obj.memids[i])
      }
      if (packedLen) {
        buf[offset++] = 74
        varint.encode(packedLen, buf, offset)
        offset += varint.encode.bytes
      }
      for (var i = 0; i < obj.memids.length; i++) {
        if (!defined(obj.memids[i])) continue
        encodings.sint64.encode(obj.memids[i], buf, offset)
        offset += encodings.sint64.encode.bytes
      }
    }
    if (defined(obj.types)) {
      var packedLen = 0
      for (var i = 0; i < obj.types.length; i++) {
        if (!defined(obj.types[i])) continue
        packedLen += encodings.enum.encodingLength(obj.types[i])
      }
      if (packedLen) {
        buf[offset++] = 82
        varint.encode(packedLen, buf, offset)
        offset += varint.encode.bytes
      }
      for (var i = 0; i < obj.types.length; i++) {
        if (!defined(obj.types[i])) continue
        encodings.enum.encode(obj.types[i], buf, offset)
        offset += encodings.enum.encode.bytes
      }
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      id: 0,
      keys: [],
      vals: [],
      info: null,
      roles_sid: [],
      memids: [],
      types: []
    }
    var found0 = false
    while (true) {
      if (end <= offset) {
        if (!found0) throw new Error("Decoded message is not valid")
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.id = encodings.int64.decode(buf, offset)
        offset += encodings.int64.decode.bytes
        found0 = true
        break
        case 2:
        var packedEnd = varint.decode(buf, offset)
        offset += varint.decode.bytes
        packedEnd += offset
        while (offset < packedEnd) {
          obj.keys.push(encodings.varint.decode(buf, offset))
          offset += encodings.varint.decode.bytes
        }
        break
        case 3:
        var packedEnd = varint.decode(buf, offset)
        offset += varint.decode.bytes
        packedEnd += offset
        while (offset < packedEnd) {
          obj.vals.push(encodings.varint.decode(buf, offset))
          offset += encodings.varint.decode.bytes
        }
        break
        case 4:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.info = Info.decode(buf, offset, offset + len)
        offset += Info.decode.bytes
        break
        case 8:
        var packedEnd = varint.decode(buf, offset)
        offset += varint.decode.bytes
        packedEnd += offset
        while (offset < packedEnd) {
          obj.roles_sid.push(encodings.int32.decode(buf, offset))
          offset += encodings.int32.decode.bytes
        }
        break
        case 9:
        var packedEnd = varint.decode(buf, offset)
        offset += varint.decode.bytes
        packedEnd += offset
        while (offset < packedEnd) {
          obj.memids.push(encodings.sint64.decode(buf, offset))
          offset += encodings.sint64.decode.bytes
        }
        break
        case 10:
        var packedEnd = varint.decode(buf, offset)
        offset += varint.decode.bytes
        packedEnd += offset
        while (offset < packedEnd) {
          obj.types.push(encodings.enum.decode(buf, offset))
          offset += encodings.enum.decode.bytes
        }
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defined (val) {
  return val !== null && val !== undefined && (typeof val !== 'number' || !isNaN(val))
}
